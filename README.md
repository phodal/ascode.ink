# 代码化：万物即代码

> 本系列文章是根据《[云研发：研发即代码](https://github.com/phodal/cloud-dev)》一文编写的具体实现。

目录

 

*   [代码化：万物即代码](#代码化：万物即代码)
*   [前言：从微架构到低代码、云开发、云研发的设计](#前言：从微架构到低代码、云开发、云研发的设计)
    *   [引子](#引子)
    *   [云研发路线图](#云研发路线图)
        *   [实施过程](#实施过程)
            *   [1\. 构建能力复用平台](#1-构建能力复用平台)
            *   [2\. 精心设计胶水式框架及能力](#2-精心设计胶水式框架及能力)
            *   [3\. 完成生命周期闭环：定制胶水语言](#3-完成生命周期闭环：定制胶水语言)
            *   [4\. 建立反向反馈，以持续优化：同构](#4-建立反向反馈，以持续优化：同构)
        *   [三个要素](#三个要素)
    *   [云开发](#云开发)
        *   [什么是云开发？](#什么是云开发？)
        *   [1\. 云 IDE](#1-云-ide)
        *   [2\. 分钟级部署的基础设施](#2-分钟级部署的基础设施)
        *   [3\. 生命周期打通](#3-生命周期打通)
        *   [如何验证云开发是成熟的？](#如何验证云开发是成熟的？)
    *   [低代码](#低代码)
        *   [什么是低代码？](#什么是低代码？)
        *   [1\. 生命周期自动化](#1-生命周期自动化)
        *   [2\. 流程代码化、数据化](#2-流程代码化、数据化)
        *   [3\. 持续完善的基础设施](#3-持续完善的基础设施)
        *   [低代码的复杂度](#低代码的复杂度)
    *   [万物代码化](#万物代码化)
    *   [云研发](#云研发)
        *   [什么是云研发](#什么是云研发)
    *   [无代码](#无代码)
    *   [其它](#其它)
*   [文档代码化](#文档代码化)
    *   [引子 1：架构决策记录：格式化文档](#引子-1：架构决策记录：格式化文档)
    *   [引子 2：静态站点生成：数据代码化](#引子-2：静态站点生成：数据代码化)
    *   [引子 3：定制的标记语言：扩充](#引子-3：定制的标记语言：扩充)
    *   [引子 4：编辑-发布-开发分离：面向非技术人员](#引子-4：编辑-发布-开发分离：面向非技术人员)
    *   [文档代码化](#文档代码化-1)
        *   [为什么你需要将文档代码化？](#为什么你需要将文档代码化？)
        *   [什么是文档代码化？](#什么是文档代码化？)
    *   [如何设计一个文档代码化系统？](#如何设计一个文档代码化系统？)
        *   [1\. 确立关键因素](#1-确立关键因素)
        *   [2\. 实现一个 MVP](#2-实现一个-mvp)
        *   [3\. 扩展语法](#3-扩展语法)
        *   [3.1 重写 markdown 渲染器](#31-重写-markdown-渲染器)
        *   [4\. 发布这个项目](#4-发布这个项目)
    *   [总结](#总结)
*   [需求代码化](#需求代码化)
    *   [引子 1：需求关联实现](#引子-1：需求关联实现)
    *   [引子 2：提交信息规范化](#引子-2：提交信息规范化)
    *   [引子 3：行为驱动开发](#引子-3：行为驱动开发)
    *   [引子 4：三段式](#引子-4：三段式)
        *   [Given-When-Then](#given-when-then)
        *   [显示-行动-响应](#显示-行动-响应)
    *   [引子 5：代码化而非数据库](#引子-5：代码化而非数据库)
    *   [需求代码化](#需求代码化-1)
        *   [需求要素](#需求要素)
            *   [目标](#目标)
            *   [系统](#系统)
            *   [角色](#角色)
            *   [数据](#数据)
        *   [建模](#建模)
    *   [需求代码化成熟度](#需求代码化成熟度)
        *   [0\. CRUD](#0-crud)
        *   [1\. 模板化需求](#1-模板化需求)
        *   [2\. 可视化](#2-可视化)
        *   [3\. 需求门禁：校验需求](#3-需求门禁：校验需求)
        *   [4\. 需求评级模型](#4-需求评级模型)
        *   [5\. 重构需求](#5-重构需求)
*   [设计代码化](#设计代码化)
*   [代码代码化](#代码代码化)
*   [构建代码化](#构建代码化)
*   [部署代码化](#部署代码化)
*   [运营代码化](#运营代码化)

# 前言：从微架构到低代码、云开发、云研发的设计

PS：过去的几个月里，我陆陆续续和不同公司的人一起讨论了开发、研发的未来。光是发我写过的几篇文章的链接，已经不能很好地解决问题。所以我决定写一篇长长的文章，来帮助更多地人理解：研发的未来在哪里？

> 一个逻辑学家可从一滴水推断出大西洋和尼亚加拉瀑布的存在，而不必听说或着见到它们。 —— 《福尔摩斯》

我也是从我的所做、所见、所听中，构建了整个的模型，并非从未来穿越到现在，所以其中的一些设想，可能并非如此准确。

## 引子

开发了一个又一个项目，撸了一个接一个的轮子，已然习惯了各式各样的软件开发流程。每一种模式自有自己的优缺点，也各自有自己的适用场景。而随着历史车轮的缓缓前进，开发流程都在不断地演进，以致于诸多的人都在想：未来的开发是怎样的？

我亦是如此。（PS：为了让大家更好地理解此文，我先说一下我相关的一些上下文）

2017 年，为了解决微服务和 BFF 的最后一公里问题，我开始研究 Serverless，并写下了国内第一本 Serverless 相关的电子书《Serverless 应用开发指南》。过程中，有幸进入了一个 APP 插件化的项目，顺带学会了移动端的 “微服务” 相关的思想。随在 2018 年，便思考着在前端如何去做微服务，写下了国内最早的微前端电子书《微前端的那些事儿》，后来出版《前端架构：从入门到微前端》。自此，大抵说得上是掌握了应对大型应用和轻量级应用的架构设计方案。

2019 年初，我开始思考开发流程的各种自动化，便基于自身的经验和开源社区的项目，构思了低代码/无代码系统架构的设计，也就有了国内最早的低代码架构设计的文章《无代码编程》。随后，我不断去探索尝试一些更好的解决方案，其中一个方案便是《云研发：研发即代码》。（PS：不好意思走得太快了）

装逼到此结束。

---------------

## 云研发路线图

有了上述的各种蛛丝马迹，我想很多人已经有了一个大体上也能有点印象：

![云研发](images/codify-roadmap.png)

这个图略微复杂一点（有些线也没划上），它展示的是组织内前后端能力复用的过程。而云开发、低代码之所以能在某些组织内落地，很大一部分原因也来自于：持续性的能力复用。有了这张图，我们可以很容易推层出其中的实施过程。

按照这个路线图，我把整个过程划分为四部分：

1. 云开发。即软件的开发流程都可以在云端完成，所有相关人员只需要一浏览器就能完成工作。
2. 低代码。需求的变更，可以影响到代码的生成。
3. 万物代码化。由低代码到无代码、云研发的关键技术。
4. 云研发。某个需求的变更，能直接完成部署。如需求对数值的更改，能直接映射到代码的修改，并上线。

如果你还没有放弃此文的话，让我们继续往下走。

### 实施过程

总体来说，我把实施过程划分为了四步：

1. 构建能力复用平台
2. 精心设计胶水式框架及能力
3. 完成生命周期闭环：定制胶水语言
4. 建立双向反馈，以持续优化：同构

事实上，如果你熟悉 DevOps 的实施流程的话，它与这个实施过程还是相似：

1. 闭环
2. 建立反馈
3. 持续优化

稍有有点不同的是，云研发的建立过程要更为精细化许多。

#### 1. 构建能力复用平台

继续从上图中的左下角的方块讲起。近几年，中台十分火热，不断有新概念，也不被地被置疑。我并非一个中台专家，从个人的角度来看待，中台更像是一个垃圾回收站。而受部门墙的影响，大型组织下的部门的核心业务，到底不会交由中台来管理？便是另外一个问题。

但是不论中台的结果怎样，它做了一件有了不起的事情，**引发了管理者对于服务复用的思考**。提升复用率，意味着提升组织的整体效能，减少了一定的内部浪费。

同样的，这种复用的机制，也出现在组织内的前端基础建设、APP 基础设施建设等等。它们出现的本质就是为了提升组织级的开发效率，减少创造重复的轮子。

所以，落地组织级别的云研发有一个很大的前提是，能实现组织内的技术能力复用。这里的组织是相对的，因为大公司的某一部部门本身类似于中型公司的开发能，以此类推。所以，在公司这一级别上，他们可能会有各种重复的轮子，其主要受限于各自的场景及未来的假设之间的差异。

#### 2. 精心设计胶水式框架及能力

技术能力复用，意味着：我们可以把上述的每个技术能力视为一个个的乐高。在构建应用的时候，我们只需要学会如何去组装它们即可。而为了组装它们，我们需要：

1. 编制它们之间的粘合规则。
2. 设计粘合适配层，用于防腐和适配未来的新架构。
3. 制造各种粘合剂，以便于连接系统的各个部分。

因此，我们还需要一些支持快速粘合的技术作为支撑：

 - 后端接口快速适配。从过程中有，微服务 -> BFF -> Serverless -> Serverless Components，直到把基础设施弱化
 - 前端组件快速复用。这一点上便有：组件 -> 微前端架构 -> Web Components 
 - APP 快速接入。从技术上来说有：小程序、APP 插件化、H5 等

一旦完成了这些技术能力，就可以关注于如何完善胶水层。

#### 3. 完成生命周期闭环：定制胶水语言

只凭上述的两步，我们大可以完成一个简易的云研发系统。但是而为了系统的未来演进，还需要一些更先进的能力，以便于我们解耦各个开发过程。这样一来，我们可以轻松更换其中的组件，而不至于因为组件的替换，引起系统架构的巨大变化。

譬如，我们已经有了 Web 部分的快速开发，现在要支撑起 APP 的快速开发。我们不需要一起改动上下游的代码，只需根据定义好我们的接口，各自的改动都是独立的不受影响的。哪怕我们是通过采购的供应商，也可以轻松地替换供应商，避免供应商锁定。这样的接口包含了结构和数据，所以我倾向于 DSL（领域特定语言）来完成。

 - 通过在线 IDE 隐藏胶水细节。
 - 创建 DSL（领域特定语言）连接生命周期的两两节点。（PS：节点间的 DSL 是不同的）
 - 建立起系统的闭环。如通过运营数据节点里，可以直接创建用户故事，来优化系统

尽管这些胶水语言会在前期增加系统的复杂度，但是它无往而不利。

#### 4. 建立反向反馈，以持续优化：同构

> 在抽象代数中，同构指的是一个保持结构的双射。在更一般的范畴论语言中，同构指的是一个态射，且存在另一个态射，使得两者的复合是一个恒等态射。 

有过使用 DreamWeaver、WinForm 等拖拽式开发经验的开发人员，都对这种形式的低代码开发有点反感。其中的主要因由有，当我修改完代码之后，无法反馈到设计上。也因此造成了一个问题，拖拽只适用于设计阶段。当后期代码发生变更时，便无法进行演进。

解决这个问题的办法，除了更新代码生成机制，还有一种方式是通过 DSL （领域特定语言）来建立反向反馈。如设计专用的工具，来将代码的修改同步设计上，同时改变架构设计的 DSL 代码。换句话来说，通过 DSL 来建立起步骤之间的桥梁。

 - 架构同构。即已完成的代码进行解析，其生成的架构设计与模型设计是一致的。
 - 设计同构。对已设计的前端组件进行解析，其与 UI 设计图生成的模型是一致的。
 - 需求同构。对已编写的测试用例筛选解析，其与原始的需求是一致的。
 - ……

简单地来说，我们要保证系统的各个节点的一致性。最终所呈现的结果是：如果节点间不一致的话，那么只能是原始需求有问题。为此，开发人员进行的代码修改，应当是通过 DSL 的形式一步步回溯，直至自动修改了需求，或者映射到需求的问题上。

所以，需要把生命周期的每一个过程都代码化。

### 三个要素

在那篇《[云研发：研发即代码](https://github.com/phodal/cloud-dev)》 中，我们介绍了云研发的三要素，在这里仍然是我么有和的。

1. 微架构：胶水。微架构，即以模块化的组合方式协同构建大型应用（前端、后端、APP等）的架构方式。每个微应用都可以独立开发、独立部署、独立运行，对应的替换的方式有模块化、子模块的方式，微服务、APP 插件化（独立构建、独立运行）、微前端等。
2. 代码化：胶水标准化。代码化，即通过创建领域特定语言来描述某一特定的事物或流程，以用于描述它在数字世界的孪生。
3. 协作设计：文化。从诸多组织实施 DevOps 的过程，我们就可以看到：要打破部门墙并不是一件容易的事。这事实上，这才是云研发的成功关键，要让打通生命周期，意味着要打通一个个的部门墙。让各方达到目的一致，怕是得由各种绩效来保证。

有了这些理论与要素之后，剩下的就是一步步的往上堆砌代码了。

## 云开发

随着持续部署、DevOps 在各个企业的推进，越来越多的企业已经有完善的基础设施，软件开发团队只需要一个在线的 IDE，就可以完成开发工作，这就进入了云开发时代。

### 什么是云开发？

> 云开发，是一种将开发过程完全迁移至云端的云原生开发模式，开发者可以在浏览器端、客户端完成一切的软件开发活动，如代码修改、调度、本地构建、代码提交、部署等等活动。其展示形式往往是通过在线 IDE 的形式完成。

在过去的一二年里，有越来越多的云厂商，选择了云开发的模式。值得注意的是，我们在这里定义的云开发和国内云厂商定义的云开发略有不同。国内云厂商所针对的是轻量级的应用开发，这里我们所针对的是所有场景下的云开发模式。换句话来说，支持轻量级应用开发是一个必由之路（MVP）。

对于一个云开发产品来说，它具备了这么一些关键要素：

1. 云 IDE。
2. 分钟级部署的基础设施
3. 生命周期打通

依旧，最难的仍然是生命周期打通。

### 1. 云 IDE

在这里，我们所讨论的是云 IDE 集成开发环境。它意味着，我们需要将其作为入口，封装各种细节。也因此，它并不仅仅是一个编辑器能完成的。

只是呢，我们可以基于成熟的开源的云编辑器来完成基础部分：

 - VSCode Online（业内：腾讯云 Coding）
 - Eclipse Theia （兼容 VS Code，业内：华为 DevCloud）
 - Monaco Editor（VS Code 基于 Monaco）

随后，通过插件来扩展我们所需要的各种能力，打通一个个的环节。

### 2. 分钟级部署的基础设施

在云开发的模式下，我们需要多种模式的快速部署：

 - 轻量级场景。如 BFF / Serverless + 小程序
 - 开发态容器化（可选）。即在浏览器修改代码时，有一台类本地的环境在后台运行，并实现快速预览。
 - 常规部署。

这些模式都已经具备一定的成熟度，只是需要基础设施来配套上开发者的手速。

### 3. 生命周期打通

在我们解决了代码问题之后，我们还需要做各种集成，以保证：

1. IDE 支持与需求的相关联。
2. 代码与版本控制系统的关联。
3. 临时的流水线与部署环境。
4. ……

当然了，各个地方有了 API 之后，就不是问题了，唯一要考虑的可能是服务器成本。而这个成本呢，可以从开发机器上补回来。

### 如何验证云开发是成熟的？

如何验证一个云开发平台是成熟的？

关于这一点非常的简单：自举 —— 它用于云开发的代码使用云开发环境完成的。

## 低代码

云开发和低代码并没有太多的联系，既然我们不在云环境开发，依旧可以选择低代码技术。唯一有意思的是，它们所需求的基础设施是相似的。既然如此，那么为什么我们在选择架构的时候，不多走一步呢？

### 什么是低代码？

> 无代码/低代码是一种创建应用的方法，它可以让开发人员使用最少的编码知识，来快速开发应用程序。它可以在图形界面中，使用可视化建模的方式，也可以通过领域特定语言，来组装和配置应用程序。开发者可以直接跳过所有的基础架构，只关注于使用代码来实现业务逻辑。

PS：关于『[无代码编程](https://github.com/phodal/lowcode)』 的更多内容可以在我的 GitHub 上查看如何设计：https://github.com/phodal/lowcode 。

这里我们只是介绍它的几个关键因素：

1. 生命周期自动化
2. 流程代码化、数据化
3. 持续完善的基础设施

过程同样不复杂，但是它的场景比较有限，远不如云开发来得实在一点。不过，对于这些有限的场景来说，低代码有非常大的优势 —— 特定的场景，模式是特定的，能大大节省成本。

### 1. 生命周期自动化

低代码最吸引人的一点是，拖拉拽就可以快速预览和上线。这意味着，在这种模式之下，融合了软件开发生命周期几个步骤，需求、设计、编码、构建、部署、运营（+运维），并实现了部分的自动化。

为此在这个要素上，它同理于云开发模式，只是要求的范围更大。所以，我们需要打通更多地环节，才能实现更多的自动化。

### 2. 流程代码化、数据化

在低代码的流转过程中，系统需要存储中间态的结构化数据，或者是领域特定语言编写的数据，以解耦不同环节。

对于一个组织而言，如果计划购买一个低/无代码编程平台，那么需要一个中间态的语言或者数据。我们已经在先前解释了其目的，这里就不重复介绍了。

### 3. 持续完善的基础设施

在实施低代码时，它需要大量的基础设施，如：

 - 大量快速可用的后端 API
 - 分钟级部署后端 API
 - UI 组件集丰富
 - ……

除此，过程中还会有各种的新需求接入，因此还需要不断地完善：

 - 方便与第三方服务集成。
 - 灵活性。支持多语言等。
 - 对应基础设施接入机制。

### 低代码的复杂度

> 复杂度同力一样不会消失，也不会凭空产生，它总是从一个物体转移到另一个物体或一种形式转为另一种形式。

我们尝试降低一部分开发者得难度的同时，也意味着我们需要将这部分复杂度拉由自身来不来解决。

## 万物代码化

> 代码化，即通过创建领域特定语言来描述某一特定的事物或流程，以用于描述它在数字世界的孪生。

代码化是我们实现从低代码到无代码的一个过程，关于如何实践其的代码化，可以关注我后续的文章。在那一篇《[云研发：研发即代码](https://github.com/phodal/cloud-dev)》中，我们把其划为了六步：

1. 需求代码化。使用 DSL 描述需求，并能转换为设计 DSL。
2. 设计代码化。完善设计 DSL，并成架构模型和 UI 设计。同时，实现设计结果到需求的反馈。
3. 代码代码化。创建通用语言，以生成不同语言的代码。同时，代码来反馈到设计。
4. 构建构建化。代码提交自动创建构建，构建自动销毁。
5. 部署代码化。代码描述部署方式，并实现各个环境的自动化、自部署。
6. 运营代码化。所有运营、运维操作都可以通过 DSL 来描述；根据线上反馈结果，能自动创建需求优化。
 
 为了配合它，还需要其它的代码化模式：
 
  - 文档代码化。
  - 合规代码化。
  - ……

嗯，这就是人生的乐趣。所以，是时候准备招一些能造飞机的程序员了。从毕业生中培养，或许是一个更好的主意。

## 云研发

最后，让我再稍微总结一下这篇文章。

### 什么是云研发

>  云研发，是一种生于云上的闭环 + 代码化的软件开发方式。它可以让业务人员、开发人员、运营人员等在同一个云端共同协作、透明化地完成整个软件的生命周期（需求、设计、编码、构建、部署、运营），而非相互隔离，又或者是借助于多个软件才能完成工作。

它需要我们在这篇文章里提到的一系列要素，并整合起来：

1. 代码化。
2. 全生命周期打通。
3. 协作式设计。

所以，整体的实施过程便是：

1. 具备基本的远程编程能力及自动化部署。即代码无需在本地
2. 在云端能完成软件开发的完整生命周期。能在云端完成所有的软件开发的工作，并且配套
3. 云研发平台上的云研发平台。（自举）
4. 借助于代码化的方式，将软件开发的每一个步骤都变成代
5. 实现开发全流程的自动优化。如自动化的蓝绿部署，自动化选择方案，自动化优化。
6. 无人编程。Human Over

## 无代码

真正的无代码，可以使得碳基生物已经不需要存在了。

## 其它

就这么多，凑点字数到 5000。

示例代码：

 - https://github.com/phodal/story
 - https://github.com/phodal/design
 - https://github.com/phodal/code
 - https://github.com/phodal/code

相关文章：

 - https://github.com/phodal/ascode.ink
 - https://github.com/phodal/lowcode
 - https://github.com/phodal/cloud-dev

# 文档代码化

> 文档代码化，将文档以类代码的领域特定语言的方式编写，并借鉴软件开发的方式（如源码管理、部署）进行管理。它可以借助于特定的工具进行编辑、预览、查看，又或者是通过专属的系统部署到服务器上。面向非技术人员的文档代码化的一种常见架构模式是：[编辑-发布-开发分离](https://www.phodal.com/blog/editing-publishing-coding-seperate/)』，

最近一个月里，我在开发一个基于 Git + Markdown 的全新文档系统。我定制了一个基于 markdown 的标记语言，以支持起雷达图、条形统计图、思维导图等图表的文档系统。这个系统将在未来几个月内发布。当然了，视进度而看，也可能是月底。

过去的几年里，我们一直在讨论各种各样的代码化，基础设施代码化、设计代码化、需求代码化……。在我的那一篇《[云研发：研发即代码](https://github.com/phodal/cloud-dev)》中，设计了一个完全代码化的软件开发流程。而今天我们将讨论另外一个有趣的存在：文档。

在《[架构金字塔](https://www.phodal.com/blog/architecture-pyramid/)》中，我将文档定义为支撑五层架构模型的一种存在。因为文档在一个系统中是非常重要的存在，我们用它来指导开发工作，用它来记录问题，用它来写下规范……。总而言之，它很重要，所以我们重新讨论一下这个话题。

## 引子 1：架构决策记录：格式化文档

三年前，当我第一次接触到『[架构决策记录](https://www.phodal.com/blog/documenting-architecture-decisions/)』的概念时，我被它的理念所吸引：

 - 使用轻量级文本格式化语言描述重大决策
 - 跟随代码一起版本化
 - 使用某种特定的文档格式（标题、上下文、决策、状态、后果）

随后，我使用 Node.js + TypeScript 写了一个 [ADR](https://github.com/phodal/adr) 工具。现在，在我的大部分开源荐中，我都会使用它来管理一些技术决策。因为基于这个理论设计的这个文档系统真非常棒，我可以查询到：

 - 一个技术决策发生的时间和架构改变，对应的修改人
 - 回溯所有的技术决策，从中整理出架构发展过程
 - 所有的决策都是记录在版本控制系统中，可恢复
 - 易于管理和维护

对于一个长期开发的系统来说，它真的非常有用。

## 引子 2：静态站点生成：数据代码化

> 静态站点生成是一种混合式的 Web 开发方法，它通过部署预先构建的静态文件进行部署，来让开发者在本地构建基于服务器的网站。

当 GitHub Pages 成为了程序员首选的 博客/内容/文档 服务器时，他/她也采用了静态站点生成这一项技术。静态站点生成有各种各样的优点：

 - 可靠性、安全性、稳定性、可用性等更好
 - 可版本控制
 - 易于测试
 - 易于实践持续部署。提交即可上线
 - 灵活，易于定制

而事实上，静态站点生成所做的最主要的一件事是：将数据库中的数据进行代码化。采用诸如 Wordpress 这样的 CMS 时，我们是将数据存储在数据库中，以实现对于数据的 CRUD。一篇文章变为数据库二进制文件中的一个片段。

随后，静态站点生成工具做了第二件事情便是将文本内容可视化出来，便于人们阅读。这样一来，我们便实现了发布-开发分离。

## 引子 3：定制的标记语言：扩充

将数据代码化时，我们面临了一个非常大的挑战：易于编写、阅读的标记语言（如 markdown）只设计了内容的形式，缺少了内容相关的其它信息，诸如于创建时间、作者、修改时间等等。

于是各个静态站点生成器定制了自己的 markdown，添加了一些额外的信息，如 hexo 采用 `:year-:month-:day-:title.md` 的形式来管理文章的日期和标题等。这样一来说，就不需要通过读取这个文章的 Git 信息来构建出整个信息。

我们所熟悉的 GitHub Flavored Markdown 也是如此，通过不明显破坏内容格式的兼容模式来扩展 markdown 数据字段。

除此，我们可以定制基于 markdown 数据的图表、思维导图等内容。

## 引子 4：编辑-发布-开发分离：面向非技术人员

面向非技术人员设计是代码文档化的一大挑战。作为一个程序员，我们觉得 markdown 语法再简单不过了，但是对于非技术人员来说并非如此。他/她需要：一个易于上手的可视化编程器。而要实现这样一个目的，我们需要在架构上做一些转变，我们可以尝试使用 『编辑-发布-开发分离』 模式来解决这个问题。

即，我们将过程拆为了三步：

 - 编辑人员，可以使用常用的编辑器或者是定制的编辑器
 - 开发人员，编写内容的展示
 - 发布的时候，集成这两部分代码

我们依旧可以选择用源码管理的方式来管理内容。只需要将数据库接口，转变为 Git 服务器接口即可 —— 当然它们是稍有不同的。不过呢，把本地的 Git 转换为 Git remote 那就基本一致了。

如此一来，最后我们的成本就落在改造出一个基于 Git 的 markdown 编辑器。

## 文档代码化

完美，我又一次在引子里，把中心思想表达完了。

### 为什么你需要将文档代码化？

主要原因有：文档不代码化，就没有重构的可能性。

剩下的原因有：

 - 二进制的文档难以进行版本管理。想象一下 `2020-02-30.docx` 和 `2020-02-31.docx`。
 - 无法准确地知道谁是文档的修改者，大家可能都是 admin，又或者是会议上的张三
 - 找不到哪个是最新的文档
 - 文档写得很烂，但是你没办法重构二进制文档
 - 供应商绑定
 - ……

应该还有更多。

### 什么是文档代码化？

回到正题上：

> 文档代码化，将文档以类代码的领域特定语言的方式编写，并借鉴软件开发的方式（如源码管理、部署）进行管理。它可以借助于特定的工具进行编辑、预览、查看，又或者是通过专属的系统部署到服务器上。

它具备这么一些特征：

 - 使用标记语言编写内容。如 markdown
 - 可通过版本控制系统进行版本控制。如 git
 - 与编程一致的编程体验（除了内容写不了测试）

而一个高效的文档代码化系统，还具备这么一些特征：

 - 持续部署，即修改完内容可自动发布。
 - 与特定的形式组织内容索引。如以知识库的形式来组织内容。
 - 特定的文本格式。如架构决策记录、静态内容生成，以用于以提供更好的用户体验
 - 可支持 REST API。以通过编辑器来修改内容
 - 可以支持多种方式的输出。如网站标准 HTML，又或者是 Docx、Latex 等
 - 支持编辑、校对工作流
 - 支持搜索
 - 多人协作

而事实上，大部分的团队并不需要上述的高级功能，而且它们都已经有了成熟的方案。

## 如何设计一个文档代码化系统？

事实上，我们在四个引子中标明了我们所需要的要素：

 1. 使用格式化的文档
 2. 借助静态站点生成技术来发布系统
 3. 通过定制标记语言扩充能力
 4. 面向非技术人员实现编辑器

设计一个标记语言及其扩展语法，然后实现它即可。

### 1. 确立关键因素

考虑到我和我的同事们最近实现了这么一个系统，我还是忍受一下手的痛楚，简单说一下怎么做这样一个系统。我们所考虑的主要因素是：

 - 图表渲染
 - 流程图渲染
 - 可视化展示

因为由 DSL 转换成的图表易于修改，并且可以索引。于是乎，我们：

 1. 通过 markdown 的 Code 语法来扩充这些能力
 2. 使用 markdown 的 table 和 list 来提供数据 
 3. 使用 D3.js 来支持流程图绘制
 4. 使用 Echarts 来进行图表绘制
 5. 尽量使用 SVG 图片
 6. ……

### 2. 实现一个 MVP

我们使用 Angular + GitHub，快速实现了一个 MVP：

1. 我们使用 Git 作为数据库.它就可以实现多人协作的目的，并且可以追踪所有的变化
2. 我们使用 GitHub Pages 作为服务器。只要一修改文档或者代码，就会部署最新的文档。
3. 我们使用 marked.js，它可以让我们快速扩展语法。
4. 使用 textarea 结合 markdown 制作了一个简易的编辑器。

随后，我们在这个基础上进行了快速的迭代。

### 3. 扩展语法

我们使用了 markdown 的 `code` 作为图表的 DSL，扩展了这么一些语法：

- echarts。直接渲染 Echarts 图表
- mindmap。Markdown List 转为思维导图
- radar。Markdown List 转为雷达图
- process-table。带流程的图表
- process-step。另外一种带流程的图表 
- pyramid。金字塔图形
- quadrant。四象限图
- class。直接调用 CSS 的 class
- graphviz。使用 Dot 渲染图片
- mermaid。使用 mermaid 可视化
- webcomponents。调用 WebComponents 组件
- toolset。调用 Toolset 相关的组件
  - slider。权衡滑块
  - line-chart。表图

所以，对于使用者来说，只需要编写下面的代码：

```
```radar
 - 质量成熟度评估模型
  - 质量内建: 3 -> 4
  - 优化业务价值: 2 -> 2
  - 质量统一，可视化: 1 -> 5
  - 全员参与: 3 -> 4
  - 快速交付: 4 -> 5
  - 测试作为资产: 2 -> 3
  - 快速反馈: 5 -> 5

config: {"legend": ["当前", "未来"]}
\```
```

就可以生成对应的图表：

![RadarChart](https://www.phodal.com/static/media/uploads/ledge-star.png)

我们还通过 config 来输入 JSON，进行一定的懒惰化处理（不要累死自己）。

### 3.1 重写 markdown 渲染器

我们在这个过程中，遇到的最大的挑战是，随着我们对 markdown 语法的不断扩充，相关的代码已经变成了一坨大泥球。所以，我们不得不重写了这部分代码：

1. 借助于 marked.js 的 lexer 解析出 token
2. 根据 token 修改生成新的 token
3. 遍历新生成的 token，渲染出元素
4. 结合虚拟滚动，解决性能问题

已经开源在 GitHub，并发布对应的 npm 包：`@ledge-framework/render`。

### 4. 发布这个项目

我们已经在 GitHub 上发布了这个文档化系统，你可以参与到其中的使用和开发。

GitHub：https://github.com/phodal/ledge

项目首页：https://devops.phodal.com/

## 总结 

然后，你就成为了一个 Markdown 工程师，D3.js 设计师，Echart 配置管理员。

# 需求代码化

> 需求代码化，


为了解决某种需求/需要，我们计划设计一个软件系统。通过与利益相关者进行交流之后，确认了新的系统是有必要存在的。于是，我们产生了一系列的概念和想法，并通过诸如愿景梳理、用户分析等一系列的想法，我们将这些想法明确下来。

在开始软件开发前，我们定义好了产品是什么，随后梳理出了用户故事地图。我们定义了在什么场景下，需要哪些用户，在哪里做些什么事情，并对这些行为做出响应。有了这些定义之后，我们作为这个系统的架构设计师，便开始思考需要保存、显示哪些数据，才能完成这个业务目标。

## 引子 1：需求关联实现

Jira + Bmaboo

GitHub issue 示例 `done #123` or `fixed #123`，日常

## 引子 2：提交信息规范化

`git-cz`

 - build: 影响构建系统或外部依赖关系的更改（示例范围：gulp，broccoli，npm）
 - ci: 更改我们的持续集成文件和脚本（示例范围：Travis，Circle，BrowserStack，SauceLabs）
 - docs: 仅文档更改
 - feat: 一个新功能
 - fix: 修复错误
 - perf: 改进性能的代码更改
 - refactor: 代码更改，既不修复错误也不添加功能
 - style: 不影响代码含义的变化（空白，格式化，缺少分号等）
 - test: 添加缺失测试或更正现有测试

## 引子 3：行为驱动开发

> 行为驱动开发（英語：Behavior-driven development，缩写BDD）是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。

```
功能:

  场景:
    假设:
    当:
    并且:
    那么:
```

## 引子 4：三段式

### Given-When-Then

### 显示-行动-响应

```
SEE HomePage
DO [Click] "Login".Button
  REACT Success: SHOW "Login Success".Toast with ANIMATE(bounce)
```

所见-所动-所得

## 引子 5：代码化而非数据库

1. 高透明性
2. 高自治性
3. 不可篡改性
4. 高安全性

这可不是区块链技术，这是需要代码化技术，【狗头】。

# 需求代码化

> 需求代码化，即将软件开发需求抽象为特定的领域语言，并使用管理代码一样的方式来管理需求，追踪需求的变化 。同时，为通过新的 API 来对接版本管理系统，以可视化需求，演变为看板代码化。

为了解决某种需求/需要，我们计划设计一个软件系统。通过与利益相关者进行交流之后，确认了新的系统是有必要存在的。于是，我们产生了一系列的概念和想法，并通过诸如愿景梳理、用户分析等一系列的想法，我们将这些想法明确下来。

在开始软件开发前，我们定义好了产品是什么，随后梳理出了用户故事地图。我们定义了在什么场景下，需要哪些用户，在哪里做些什么事情，并对这些行为做出响应。有了这些定义之后，我们作为这个系统的架构设计师，便开始思考需要保存、显示哪些数据，才能完成这个业务目标。

在进入开发之前，这些想法设计等，都被明确为软件需求，简称为需求。

> 软件需求指为用户解决某一问题或达到某一目标所需的软件功能；系统或系统构件为了满足合同、规约、标准或其他正式实行的文档而必须满足或具备的软件功能。

为了进入万物代码化的世界，首先我们得准备一堆机制，以将物理世界的目标转换为软件问题。即我们要将软件需求，转换为代码。

## 引子 1：需求关联对应代码

事实上，关于这部分的内容已经存在了很久了。

早期，我们在项目上使用 Atlassian Bamboo + Atlassian Jira 时，它们已经可以非常好地配合在一起。你可以从持续集成上，直接跳转到需求处。

另外一种模式，则是透明的开源模式。如 GitHub 的 issue 与提交信息的关联，使得我们可以通过 `done #123` or `fixed #123` 的形式来关联一个 issue（可能是需求），并关闭这个 issue。

反之，我们可以通过一个需求，来找到对应的代码提交。

## 引子 2：提交信息规范化

作为一个懒散的开源项目造轮子工程师，我习惯性地采用了社区规范的提交信息，以便于生成项目的 ChangeLog。诸如于：`docs(changelog): update change log to beta.5`，它遵循的是如下的示例：

```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```

如下是部分类型的示例：

 - build: 影响构建系统或外部依赖关系的更改（示例范围：gulp，broccoli，npm）
 - ci: 更改我们的持续集成文件和脚本（示例范围：Travis，Circle，BrowserStack，SauceLabs）
 - docs: 仅文档更改
 - feat: 一个新功能
 - fix: 修复错误
 - perf: 改进性能的代码更改
 - refactor: 代码更改，既不修复错误也不添加功能
 - style: 不影响代码含义的变化（空白，格式化，缺少分号等）
 - test: 添加缺失测试或更正现有测试

为了这套提交信息模板，我们就可以结合 `git-cz` 这样的工具，在本地进行提交信息的规范化。同时，在 Git 服务器里，设置对应的提交信息门禁——即如果提交信息不满足规范，则代码无法提交到服务器中。

与之更为相似的一个概念是：

> 代码门禁能够确保每一个进入主分支的commit都达到了一定的质量标准，例如：编译必须通过，单元测试和接口测试必须通过，新代码的覆盖率不能低于某个水平，静态代码扫描必须通过。

## 引子 3：行为驱动开发语言

BDD 这个东西，大家都比较熟了。这里就不详细介绍了：

> 行为驱动开发（英語：Behavior-driven development，缩写BDD）是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。

流行的 BDD 工具 Cucumber 背后是一个名为 Gherkin 的 DSL，它用于描述需求及测试。

```gherkin
功能:

  场景:
    假设:
    当:
    并且:
    那么:
```

换句话来说，它可以作为我们的需求描述语言规范。

## 引子 4：三段式结构 

三段式，大家都比较熟悉，我们可以按自己的需求，将所有的东西都转化为三段式：

 - BDD 的：Given - When - Then
 - UI 设计的显示 - 行动 - 响应
 - 前端开发的：展示 - 事件 - 响应
 - HTTP 请求的：request - handle - response
 - 代码的：输入参数 - 处理 - 输出结果
 - 测试的：Arrange-Act-Assert
 - ……

如果不熟悉的话， 可以简单地看一下我之前设计的一个设计语言示例：

```
SEE HomePage
DO [Click] "Login".Button
  REACT Success: SHOW "Login Success".Toast with ANIMATE(bounce)
```

就这么简单。

## 引子 5：源码控制管理而非数据库

在上一篇文章《文档代码化》中，我们已经建议了开发人员使用像代码一样的文档语言，使用 Git 来管理文档。它有这么一些优点：

1. 高透明性
2. 高自治性
3. 不可篡改性
4. 高安全性

这可不是区块链技术，这是需求代码化技术，【狗头】。当我们的需求变成了代码，那么我们就有了一个去中心化的看板。

## 需求代码化

好了，现在我们有相同的上下文，让我们回到正题上：

> 需求代码化，即将软件开发需求抽象为特定的领域语言，并使用管理代码一样的方式来管理需求，追踪需求的变化 。同时，为通过新的 API 来对接版本管理系统，以可视化需求，演变为看板代码化。

它具备这么一些特征：

1. 使用标记语言编写内容。如 Cucumber
2. 可通过版本控制系统进行版本控制。如 git
3. 与编程一致的编程体验，还可以作为测试代码的一部分
4. 支持集成到现有的看板系统中
5. 可集成到 IDE 中协作
6. 支持 Git 转换为 CRUD 接口

为了进一步实现万物即代码，它还具备这么一些特征：

1. 可对需求进行重构
2. 可转化为设计语言

或许，聪明的你已经知道了怎么做这样的系统了。

## 如何实现一个需求即代码和我比主

事实上，我们在五个引子中标明了我们所需要的要素：

1. 设计需求代码化 DSL
2. 过渡 API 设计
3. REST 接口转换 SCM 接口（如 Git）
4. 静态 API 生成（用于燃尽图等）
5. IDE 集成看板
6. DSL 可视化看板
7. 删除原有的看板系统

稍有不同的是，我们要进一些额外的设计。

### 最小需求模型

在我们对需求进行建模的时候，我们需要考虑一个需求的最小要素，如下：

1. ID
2. 开始时间
3. 结束时间
4. 优先级
5. 状态
6. 作者
7. 开发者
8. 标题

【狗头】，这个是我在设计 phodal/design 时候设计的字段，顺便一提。

### 重新设计需求的组织形式

现有的看板系统都存在一个问题，只让业务人员写一个标准答案。而缺少中间的过程设计，因此如果想降低编写需求的成本，那么应该重新设计一下需求的组织形式。现有的需求的组织形式，有：『影响地图』和『用户旅程地图』。

其实我们要做的事情很简单，即我们只有最后能可视化出『用户旅程地图』即可，然后往 DSL 添加新的字段即可。

### 需求 DSL 的要素

如果现有的三段式 DSL 不满足需求，那么可以回过头来看看需求的要素是什么？

 - 目标。系统的业务价值，基于价值确定功能和需求的优先级。
 - 人员。使用系统的人员以及业务流程和目的。
 - 系统。存在什么系统，用户界面是什么样，系统间如何交付，系统的性能怎么样？
 - 数据。三者的关系，从最终用户角度看到的业务数据对象、数据的生命周期、报告中数据对决策的影响。

基于这四要素，我们可以重新设计我们的需求 DSL。

### NLP 建模过程

在我们的系统进一步完善之后，我们要采用 NLP（自然语言处理）对需求进行分析，从中提取上述所涉及的四要素，进而将需求转换为代码。

1. 提取名词
2. 抽象行为
3. 关注数据及状态
4. 建模
5. 实例化
6. ……

考虑到写需求的业务人员并不会为难这个系统（譬如写一个多重否定），NLP 并不会太复杂的。

## 原型示例

接着，让我们来看我去年写的一个示例，基于 Cucumber + 其注释设计的：

```cucumber
# id: TUgT7FxZg
# startDate: 2019-11-22T01:56:41Z
# endDate: 2019-11-22T02:06:48Z
# priority: 
# status: thinking
# author: phodal
# title: image to dsl
# language: zh-CN
@math
Feature:image to dsl

  Scenario: 作为设计师，我想直接获得一份草图生成的 DSL
    Given 设计
    When 当我在设计的时候
    Then 我能将草稿转成 DSL
    Then 这样我能直接将草图转成 SVG
    Then 开发人员可以直接修改代码
```

通过 CLI 就可以查看对应的情况，诸如于：

```

+-----------+--------------------------------+----------------------+--------+--------+
|    ID     |             TITLE              |         DATE         | STATUS | AUTHOR |
+-----------+--------------------------------+----------------------+--------+--------+
| CYJlzObWR | add docs to README             | 2019-11-21T15:33:50Z |        |        |
+-----------+--------------------------------+----------------------+--------+--------+
| Dyp0iOxZg | use cucumber tag as file s     | 2019-11-21T15:45:47Z |        |        |
|           | group                          |                      |        |        |
+-----------+--------------------------------+----------------------+--------+--------+
```

并且它作为代码的一部分，贯穿在整个应用的生命周期中。

GitHub：[https://github.com/phodal/story](https://github.com/phodal/story)

## 需求代码化成熟度

为了方便大家后期完善这个系统，我决定写一个简单的成熟度模型。

### 0. 模板化需求

最简单的模式就是采用 Cucumber 的语法，它包含了现成的语法和 IDE 支持等。对于开发人员、测试人员、业务人员也比较熟悉。

### 1. 需求代码化

如上。

### 2. 需求像代码一样管理

1. 设定需求门禁
2. 不满足原则时（如 INVEST 原则），无法提交需求

### 3. 看板即代码

简单来说，就是：

1. 支持 Git 的 CRUD
2. 支持将现有的看板对接到 Git API

### 4. 需求关联设计

1. NLP（自然语言处理），进行分词的状态转换设计。
2. 需求建模语言。
3. 需求的自动化测试

即能从需求中，识别中目标、系统、人员和数据等四个要素。

### 5. 需求转换代码

需求转换为设计代码 DSL，即我下一步要做的事情。

## 重构需求

Wow，现在我们已经成功地把文本代码化了，那么下一步就能重构这些代码（需求了）。

## 结论


参考书籍：

 -《软件需求与可视化模型》


# 设计代码化

> UI 设计代码化，即将软件的 UI 设计与 UI 交互转换为特定的领域语言，并使用代码的方式来进行管理。它可以直接将需求转换为 UI 原型，让设计人员基于此进行设计；还负责将其转换对应的 UI 代码，方便开发人员进行编写。

在 Uncode IDE 里，设计代码化是由两部分组成：架构设计（代码设计）代码化与 UI 设计代码化，这是一个相当复杂的领域。作为一个在前端领域的专家，我是在去年完成了 UI 设计代码的第一个版本的设计；作为半个架构专家，我则是在最近完成了部分架构设计代码化的工作。

在最近 ，我刚使用 Rust 将去年设计的 UI DSL 重写，于是重新命名为 Unflow。想不到一个更好的名字，于是将它与 Uncode 进行了一个简单的对应。你可以在 GitHub 上看到 Unflow 当前（早期）版本的设计：[https://github.com/inherd/unflow](https://github.com/inherd/unflow) 。

在继续往下阅读之前 ，我要做一个简单的声明：在完成了 Unflow 的设计之后，我一直在等待机会能与一些用户体验设计师合作，以完善整个 DSL。但是呢，一直没有找至一个合适的机会。所以，当前的这个 DSL 并不一定接近真实的设计师体验。

所以呢，如果你对优先这个 DSL 有兴趣，可以一起参与设计。

## UI 设计代码化

> UI 设计代码化，即将软件的 UI 设计与 UI 交互转换为特定的领域语言，并使用代码的方式来进行管理。它可以直接将需求转换为 UI 原型，让设计人员基于此进行设计；还负责将其转换对应的 UI 代码，方便开发人员进行编写。

### 为什么需要 UI 设计代码化？

在文章开头里，我们定义了一下：UI 设计代码化。但是呢，为什么我们需要一个这样的代码化工具呢？从整个云研发体系来说，将 UI 设计代码化，我们要做的这么几件事：

1. 用户交互文档化。即所有的 UI 交互过程，以明确的格式记录下来，并与文档的形式存储。
2. UI 工具无关。采用标准化的方式描述 UI 设计，让 UI 设计与 UI 设计工具脱离。
3. 双向反馈。即我们的设计与 UI 原型、代码是相绑定的，当代码与设计不一致时，我们能即时得到反馈 —— 要么修改设计，要么修改代码。
4. 连接需求与代码的胶水。从某种程度上来说，这个 DSL 还承担着作为需求与代码连接的胶水。即将需求转换为设计的描述，以便于这个描述转换为代码。

在云研发体系中，它是非常重要的一环。

### 如何进行 UI 设计代码化？

在今天来看，将 UI 设计进行代码化已经变得相当的简单。只是呢，还有一些因素，会限制我们的代码化能力：

**矢量可编程的 UI 设计**。

UI 工具是整体过程中最令人头痛的问题。对于 UI 设计而言，如果它产出的内容不是矢量图形，那么它会限制我们的转换能力 —— 一个二进制文件不适合在代码库中存储。而，如果一个 UI 工具产生的格式是可直接编程操作的，那么就再好不过了，比如 SVG。但是呢，SVG 缺少一些引用等的相关设计。不过呢，Sketch 也是一个非常不错的工具，它的格式是易于进行编程操作的。

**UI 元素可编程**。

在进行 UI 设计的时候，我们会定义出一套 Design Sytem 或者 UI Guideline，上面充满了丰富的元素，如组件、字体等。对于这些元素来说，它应该是可以由代码生成，或者直接转换为设计 DSL。以用于**核验**代码中的元素是否真的与设计**匹配**。

**对于交互的抽象**。

对于交互的抽象是一个烦人的问题，但是呢，在我深入研究与探索之后，我发现这也不是一个复杂的问题。复杂度并不高，只是呢，我们要考虑如何与我们的设计、代码进行关联，形成统一的关系。

## UI 设计代码化要素

综上所述，我们在对 UI 进行代码化时，要考虑这么一些要素。

### 要素 1：代码反馈设计

在云研发体系里，我们将所有一切代码化有两个原因：

1. 流程代码化，并实现化转换自动化。
2. 借助反馈进行自动优化。

对于 UI 设计代码化这一步来说，我们要：

1. 寻找合适的 UI 设计工具及对应的解析库，以将解析 UI 设计，转换为特定的领域语言。
2. 能解析修改过后的生成代码，将代码实现与 UI 设计进行对比。
3. 自动绑定 UI 设计与代码，自动修改、提示不合理的地方。

### 要素 2：支持增量变更

设计与代码是相似的，在开发过程中，会伴随着需求的变化，影响到 UI 设计上的变化。因此，对于 UI 设计产物来说，它们应该：

1. 可版本化。与代码库同在，能跟踪到设计的历史变化。
2. 可编码。可以由需求生成设计，由代码反馈到设计。

在有了这两个条件的情况下，我们可以进行增量变更。

### 要素 3：抽象交互 

尽管，我在本文中提出了一套交互相关的 DSL，但是它并不是那么完善。除此呢，在不同的公司里，人们也会自己的一些特定的 UI 设计模式等。所以呢，我们还需要设计一种抽象来描述系统对于用户的交互。

对于一个交互 DSL 来说，它需要做两件事：

1. 描述用户交互。
2. 能与需求进行对应。
3. 能与代码进行对应。

接下来，让我们看看 Unflow DSL 的设计。

## Unflow DSL

基于此呢，我们设计了 Unflow，它具备了如下的三个模式：

1. 三段式交互设计：SEE-DO-REACT
2. 拆分设计：原子设计
3. 布局系统：AutoLayout 与 Flex 布局

除此呢，还有一个非常重要的部分：反馈式设计，我暂时还没有去验证。

## 模式 1 —— 三段式交互设计：SEE-DO-REACT

在日常的软件开发活动中，我们经常会看到不同的三段式表达：

 - BDD 里的：Given - When - Then
 - UI 设计的：显示 - 行动 - 响应
 - HTTP 请求的：request - handle - response
 - 代码的：输入参数 - 处理 - 输出结果
 - 测试的：Arrange-Act-Assert
 - 前端开发的：展示 - 事件 - 响应

对于 UI 设计来说，也存在类似的元素。我尝试着从一堆论文中寻找经验，初始时我尝试以 BDD 的三段式来总结。直到我看到了 Basecamp 的设计师 Ryan 在『[A shorthand for designing UI flows](https://signalvnoise.com/posts/1926-a-shorthand-for-designing-ui-flows)』一文中看到几句话：

 - What the user sees
 - What them do
 - What them see next / what them do next

基于此，添加了一个 React 的选项，即系统要对他们做出什么响应。于是，有了一个简单的 DSL 原型：

```
flow 登录 {
  SEE 首页
    DO 输入密码
    DO [点击] "登录".Button
        REACT 成功: 展示 "Login Success".Toast with ANIMATE(bounce)
        REACT 失败: 展示 "Login Failure".Dialog
}
```

这里的 SEE 对应了用户的所见，DO 则是对应于用户所做，而 REACT 则是相应的可能结果。我们可以将它与需求代码化里的 Given-When-Then 进行一一应对。稍有区别的是，这里在 REACT 里进行了合并，方便后续与 UI 代码进行对应：

1. 调用接口成功的场景下，则显示 Login Success，然后再往下进行操作。
2. 调用接口失败的场景下，则显示 Login Failure 弹窗（Dialog），然后可以添加其它行为。

上述代码中的首页，可以对应到 UI 设计的场景、原型上，对应的按钮（Button） 则是组件使用上的声明。与此同时，基于上述的一系列关键描述，如 Login Success、Login Failure 还创建了对应的 UI 设计上的场景。

##  模式 2 —— 元素拆分：原子设计与元素定义

在设计人员与开发人员协作的过程中，Brad Frost 创建了原子设计的概念：原子设计是一个设计方法论，由五种不同的阶段组合，它们协同工作，以创建一个有层次、计划性的方式来界面系统。

于是，在 Unflow 中，我们依然采用了这个理念，与之对应的设计是：

 - 原子 - library。描述基础、库组件的一些要素。
 - 分子级 - component。描述组件
 - 有机体 - component。描述组件 
 - 模板 - template。
 - 页面 - page

这里的 library、component、template、page 都是 Unflow 中的定义。Unflow 的 DSL 只是提供定义，如下是一个对于颜色规范的定义：

```
library Color {
    Primary {
        label = "Primary"
        value = "#E53935"
    }
    Secondary {
        label = "Blue"
        value = "#1E88E5"
    }
    Third {
        label = "Third"
        value = "#000000"
    }
}
```

Unflow 定义的是这些要素，随后结合其它工具进行转换。在早期 ，我们结合 Node.js 里的 Sketch Constructor 进行了转换，它将转变为两部分：Sketch 里的颜色规范定义，以及前端代码库里的 SCSS 定义。

这种定义方式，对于 `component`、`page` 也是类似的。

```
page HomePage {
    LayoutGrid: 12x
    LayoutId: HomePage
    Router: "/home"      # 由开发定义
}
```

稍有不同的是，我们在设计中加入了一个路由的概念，这个后期可以由开发人员来进行补充。

顺带一说，依旧的这只是 Unflow 的第一个版本，所以在设计上会比较粗糙。

##  模式 3 —— 布局系统：Flex

起先，如果只是站在早期的布局系统的维度之下，我怕是没有胆量去设计一个 DSL。而随着不同领域对于 Flex 布局的统一化程度：

 - 移动端框架 Flutter 中的线性布局（Row、Column）
 - 原生 UI 框架 Druid 采用的 Flex 布局
 - 前端领域采用的 Flex 布局
 - Android 端的 FlexboxLayout
 - ……

那么，对于我们的布局系统来说，自然采用的是类似于 Flex 布局。如此一来，我们只需要考虑一下结合 Apple 的 Auto Layout，就能得到一个勉强可以用的 UI 系统。

而，我最早对于 Layout 体系的想法，语法来源是 [autolayout.js](https://github.com/IjzerenHein/autolayout.js)。一个在前端实现了 AutoLayout 和 Visual Format Language 的布局系统，它的语法如下：

```javascript
H:|[view1(==view2)]-10-[view2]|
V:|[view1,view2]|
```

虽是如此，我设计的第一个版本的布局系统有点不那么实用。关于这一点，我还在自我反思 ，为什么会设计出这么难写的语法：

```
Layout Navigation {
--------------------------------------
| "home" |"detail" | Button("Login") |
--------------------------------------
}
```

在设计布局的时候，想的是：

1. 以 Flex 作为实现方式
2. 以 Table 作为展示形式，方便开发人员维护
3. 支持组件上的参数传递

在这种限制的交错之下，就有了现在这种奇怪的设计。

##  其它 

Unflow 正在设计中，欢迎为 Unflow 提出您的意见：[https://github.com/inherd/unflow](https://github.com/inherd/unflow)

参考资料：

 - [A shorthand for designing UI flows](https://signalvnoise.com/posts/1926-a-shorthand-for-designing-ui-flows)
 - [https://github.com/inherd/unflow](https://github.com/inherd/unflow)
 - [https://github.com/IjzerenHein/autolayout.js](https://github.com/IjzerenHein/autolayout.js)
 - [https://github.com/dorostanian/sushi](https://github.com/dorostanian/sushi)
 - [Understanding Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html)

# 代码代码化


我们想要做的事情是：把**任意的** A 语言转换为**任意的** B 语言（PS：这里的任意 A 和任意 B 语言都是主流语言）。如此一来，我们便可以：

1. 快速重写任何的系统。
2. 与编程语言无关的领域建模。
3. 产生一个更强大的 DSL。
4. 创建新的语言。

## 引子 0：统一语言模型

> 统一语言模型，即对不同的比编程语言进行抽象，使用同一套数据结构描述编程语言。

在我使用了 Golang + Antlr 实现了 Coca 之后，我意识到这是一条可行的方案。但是，由于 Coca 的架构和用途所限，外加之 Antlr 对于 Java 的支持远比 Go 要好，我并没有继续在 Coca 上实施这个方案。

于是乎，我开始了第二个尝试，使用 Kotlin + Antlr 来实现对不同语言的模型统一，也就是我的另外一个开源项目 Chapi。但是呢，随着不断的尝试，我发现了其中的难度和工作量比较大：

1. **编写不同语言的语法解析**。社区上已经有大量的成熟的轮子，其中最出名的就是 Antlr 相关的语法解析。官方维护的代码仓库（grammars-v4）包含了大量的 Antlr 语法解析案例，可以找到市面上一些主流的和非主流的实现。
2. **设计统一语言模型**。即设计出一套能兼容不同语言的语言模式。当然了，这是一个持续完善的过程，会随着更多语言的加入，变得更加完整和复杂。
3. **解析不同语言**。即根据不同语言的语法特性，转换为上述的模型。

从难度上来说，我们可以看出技术难度主要是在步骤 1 和步骤 2。而步骤 3 呢，则是一个非常繁琐、工作量巨大的体力活。我们还需要熟悉不同的编程语言，并一一解析对应的字段，才能转换每一个语言。

因此，我尝试建立起了 Chapi 的社区，然后手把手带领一群人干活。尽管，对于不同的语言我已经建立起了统一的编写模式：TDD + Tasking。似乎，很多人对于 AST 有点担心，因此参与的人非常少。所以，对于其它语言的支持就不了了之。

相关资源：

 - 详细的设计可以参考我写的那一篇：《[如何为代码建模？](https://www.phodal.com/blog/modeling-for-code/)》
 - 详细的实现可以参照：[https://github.com/phodal/chapi](https://github.com/phodal/chapi)

## 引子 1：语法高亮的背后

与此同时，哪怕有足够的人，Antlr 并非一个完美的答案。在编写不同语言的支持时，我依旧遇到一系列的 Antlr 语法不支持的问题。如 JavaScript 的 Import，Java 的一些 Lambda 问题……。换句话来说，Antlr 官方只是维护这么一个库，真实的效果就不得而知了。

于是，我就回到了一条老路上，使用正则——当然不会自己写了。在那篇《[编程语言的 IDE 支持](https://www.phodal.com/blog/language-in-ide/)》中，我提到了**基于正则表达式来实现语法分析**，其中介绍了两个编辑器的实现方式：

 - Sublime Text 基于 YAML 形式的正则匹配方式：[Sublime Syntax files](http://www.sublimetext.com/docs/3/syntax.html#include-syntax)
 - Textmate、VS Code 基于 JSON 的正则匹配方式：[Language Grammars](https://macromates.com/manual/en/language_grammars)

所以，我们选择了 VSCode 作为了语法解析背后的语言。在这种模式之下：

1. 我们有一个成熟稳定的语言解析工具，并且也有一个巨大的团队在维护它们。
2. 它的社区是非常庞大的，经过大量的反复提升。

因此，我和我的同事从几个前开始编写：[https://github.com/phodal/scie/](https://github.com/phodal/scie/) —— 一个基于 TextMate  语法高亮的库。

## 引子 2：代码生成与 JavaPoet

在我们粗糙地完成了 Scie 之后，我开始思考着下一步：**如何从 A 语言转换为 B 语言的时候**，我从 JavaPoet 获取到了一些灵感。JavaPoet 是一个用来生成 `.java` 源文件的 Java API。如下是一个简单的 JavaPoet 代码示例：

```java
TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")
    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
    .addMethod(main)
    .build();
```

也就是说，我们可以写一个 API，以将某语言转换为 B 语言的源码。而要实现任意语言的转换，那么我们就需要实现一个 DSL：用于**描述不同语言与统一模型的差异**。后来，我意识到我还需要另外一个 DSL，用于**转换统一模型到不同的语言**。

## 引子 3：中间表示的演变

> 编译器的核心数据结构是被编译程序的中间形式。 —— 《编译器设计》

理论上，通过上述的两种方式，我们就可以直接生成不同领域的模型。但是呢，为了调试方便，可以创建一个中间语言来作为它们的承载物，可以让我们实现更有意思的事情，去统一进行编译器优化——当然，我是瞎说的。

随后项目的原因，我研究了一小段时间的 Proguard + D8 和 Android R8 的实现上。它们两做的事情是相似的，将 `.class` 字节码，编译优化，再转换成 Android 手机上的 dex。当然了，转换为 Aot 就是一个更有意思的话题了（虽然我也不熟悉）。但是呢，这期间涉及到了一系列的中间状态：`java -> .class -> .dex -> odex -> .oat`。即从 Java 代码到 JVM 虚拟机字节码 -> Dalvik 虚拟机字节码 -> 优化过后的 Dalvik 字节码 -> ART 机器码。

而我们再回过到来看，编码语言本身也是一种中间表示，因为机器运行的是靠机器码。即，那句经典的话：**代码是写给人看的**。

## 引子 4：DSL 的 DSL

对于有的编译器来说 ，它们可能有唯一的 IR（中间表示，Intermediate representation），也可能会有一系列的 IR。最常见的一些实现，便是我们看到的那些使用 LLVM 作为后端的语言，它们可以生成中间形式的 LLVM IR。同样的对于我们想做到的事来说，我们可以设计一个类似于 LLVM IR 的高级中间表示，用于承载语言的设计。

由于项目涉及到一丁点的代码优化，所以我还阅读了一下那本《高级编译器设计与实现》，书中引入了 ICAN 这个中间语言。嗯，这就是已经被论证的结果了，不再需要我去论证它的必要性。所以下一步就是：

> 自举，在计算机科学中，它是一种用于生成自编译编译器的技术，即使用打算编译的源编程语言编写的编译器。

在业内，人们往往往把自举定义在编译器领域中。但是呢，它可以在更多的领域被应用。例如 Java 的构建工具，Gradle 使用 Gradle 来构建自己 —— 当然与编程语言相比，这事要相对容易一些。

而人的自举就是把自己替换便，让工具做了自己的事，让别人做得了自己的事。所以，我们就需要 Charj 来做自己所能做的事情。

## Charj Lang

终于回到了正题上了，在有了上面的几步之后，我们就能：

1. 通过正则表达式，解析、生成不同语言的语法树。
2. 编写 Poet API 将上述的语法树，转换为某一特定语言源码。
3. 设计某一中间语言，用来作为 A 语言转换为 C 语言的载体。
4. 实现 A 语言到 C 语言，又或者 C 语言到 A 语言的自由转换。

这便是从任意语言转换为任意语言的想法和思路。于是乎，我和我的同事们开始设计一个中间语言：Charj。

当然了，开发一个语言的目的主要是为了锻炼自己的能力，不论是抽象能力，还是算法能力等等。在这个漫长的人生里， 它将会变得有意义。以后，请叫我 Charj 语言作者。PS：你也可以是 Charj 语言作者。

回过头来看，事实上应该是这样的，我已经尝试造了各式各样的工具，从各类的编辑器到各类的命令行工具。而在学习了 Rust 之后，我研究了 JVM、编辑器底层，也正在逐一尝试创建日常所使用的工具。而在上一年里，因为编写重构工具 Coca，再到随后的转换为统一语言模型的 Chapi。对于编译器前端，我已经有了相当丰富的经验。自然而然的，创造一个语言就成了下一个方向。

### 为什么叫 Charj ？

从本义上来说，Char 是更适合 Charj 的定义的，但是 Char（仓颉）的商标已经被注册了。退而求其次，我只好叫 Charj，可以引伸为中英混合式的：字符（Char）集（Ji），又或者是字符（Char）集（姬）。又或者是『字符 J』 —— 至于 J 是什么意思，我还没想清楚。我们可以再定义，再取一个新的名字。

## Charj 进展

Charj 使用的是 Rust 为主的语言编写的。Rust 的自举已经证明了：Rust 用于开发编程语言是没有问题的。当然了，主要原因还在于让我 C++，还不如让我写 Haskell。

### Charj Lang （设计中）

Charj lang 现在的工作分为两部分：

1. 完善语法设计
2. 编译器的流程设计

尽管从理论上来说，Charj 不一定需要编译 + 可运行，但是为了自举，我们需要它们。于是，我们在后端采用了 LLVM，前端使用的是 Rust 里的 LR（1）解析器生成器 [lalrpop](https://github.com/lalrpop/lalrpop) 。

GitHub：[https://github.com/charj-lang/charj](https://github.com/charj-lang/charj)

### Charj IDE（开发中）

当前已经有一个简单的语言插件，当然只有基本的高亮和跳转功能。如果你有一定的 IDEA 插件开发经验，也可以来我们一起搞搞。

GitHub：[https://github.com/charj-lang/intellij-charj](https://github.com/charj-lang/intellij-charj)

### Scie

Scie（Simple Code Identify Engine）是一个基于正则表达式的通用语言转换器。主要开发工作基本已经完成了，但是有几个问题需要解决：

1. 效率优化
2. 调用 Oniguruma FFI 时会随机出错。

GitHub：[https://github.com/charj-lang/scie](https://github.com/charj-lang/scie)

### Charj Poet（开发中）

Charj Poet 是一个是用于生成 Charj 代码的 Rust API。计划等语法设计完，再进一步完善。

GitHub：[https://github.com/charj-lang/charj-poet](https://github.com/charj-lang/charj-poet)

### Poet DSL（待定）

两部分：

1. 即设计一个新的 DSL，来描述不同语言转换为 Charj Lang 的 DSL。
2. 即设计一个新的 DSL，来描述 Charj Lang 转换为不同语言的 DSL。

### 官网

简陋和粗糙的官网：[https://charj-lang.org/](https://charj-lang.org/)

## 其它 

此时此刻，虽然我翻过几本编译相关的书籍，我也并非一个编译原理相关的专家。所以，如果你也有兴趣，欢迎来加入我们。


# 架构即代码

> 架构即代码，是一种架构设计和治理的思想，它围绕于架构的一系列模式，将架构元素、特征进行组合与呈现，并将架构决策与设计原则等紧密的与系统相结合。

如我的上一篇文章《[为“架构”再建个模：如何用代码描述软件架构？](https://www.phodal.com/blog/architecture-model/)》中所说，要准确描述软件的架构是一件颇具难度的事情。仅就实现的层面来说，也已经很难通过一个标准模型来让所有人达成一致，“哦，这就是架构”。也因此，在无法定义架构的情况下，也很难无法给出一个让所有人信服的架构治理模型。毕竟：**模型只有合适的，永远没有对的**。

但是呢，我们（ArchGuard Team）依旧会在 ArchGuard 构建出一个架构模型，以及架构治理模型，作为推荐的 “**最佳实践**”。除此，我们还应该提供一种**自定义**企业应用架构的可能性，这就是**架构即代码**。面向初级架构师来说，他们只需要按照 ArchGuard 的最佳实践来实施即可；面向中高级架师，他们可以基于 ArchGuard 提供的插件化能力 + DSL 构建自己的架构体系。

所以，如你在其它系统中所看到的那样，要提供这样的能力，需要一定的编码、配置等。所以，我们就需要构建一个**架构即代码**的系统。那么，问题来了，即代码又是什么鬼。

## 架构即代码是什么？

在先前的一系列的代码化（<https://ascode.ink/>）文章中，描述了如何将软件开发完全代码化，包含了将文档、需求、设计、代码、构建、部署、运营等变成代码化。设计和实现一个领域特定语言并不难，如《[领域特定语言设计技巧](https://www.phodal.com/blog/step-by-step-domain-specific-language-design/)》一文中所描述的过程，在这个上下文之下就是：


1. 定义呈现模式。寻找适合于呈现架构的方式，如 UML 图、依赖图、时序图等。
2. 提炼领域特定名词。一系列的架构相关元素，如架构风格：微内核等、架构分层：MVC 等。
3. 设计关联关系与语法。如何以自然的方式来关联这些架构元素，如关键词、解析占位符等。
4. 实现语法解析。除了实现之后，另外一种还要考虑的是：如何提供更灵活的扩展能力？
5. 演进语言的设计。版本迭代

也因此，我们将架构即代码定义为：

> 架构即代码，是一种架构设计和治理的思想，它围绕于架构的一系列模式，将架构元素、特征进行组合与呈现，并将架构决策与设计原则等紧密的与系统相结合。

接下来的问题就是，如何将这个理念有机的与系统结合在一起？并友好地提供这样的 API 接口（DSL）？

于是放到当前 ArchGuard 的 PoC，架构即代码的呈现方式是 “ArchDoc”，一种基于 Markdown 的交互式代码分析和治理方式。即所有的 “代码” 都通过 markdown 来管理，优点有一大堆：

* 使用内嵌 DSL （用语法块管理）表述架构
* 可以记录系统的架构文档，如架构决策、业务架构等
* 拥有广泛的解析库，能提供更灵活的定制灵感（Ctrl + C, Ctrl + V）。
* 自定义 Render
* 广泛的编辑工具支持

唯一的缺点就是实现这样一个工具并不简单。

## 架构即代码的特点

不过，我们已经实现了一个简单的 PoC（概念证明）版本，在这个版本里，它的特点是：

* 显式地描述与呈现架构。
* 架构文档即是规则
* 设计、文档与实现一致

当然了，还有各种的可扩展能力（这是一个再普通不过的特点了）。

### 显式地描述与呈现架构

回到日常里，我们经常听架构师说，“我们的服务采用的是标准的 DDD 的分层架构”。但是，这个分层是不是诸如于 “Interface 层依赖于 application、domain、infrastructure 层” 等一系列的依赖关系？开发人员是否知道这些规则？这些都是问题。所以，一个架构即代码的系统，它应该能显式地呈现出系统中的那些隐性知识。

诸如于，我们应该将分层中的依赖关系，显式地声明写出来：

```javascript
layered {
    prefixId("org.archguard")
    component("interface") dependentOn component("application")
    组件("interface") 依赖于 组件("domain")
    component("interface") dependentOn component("infrastructure")

    组件("application") 依赖于 组件("domain")
    组件("application") 依赖于 组件("infrastructure")

    组件("domain") 依赖于 组件("infrastructure")
}
```

PS：请忽视上面 Kotlin 代码中的中文元素，它只是用来说明使用中文描述的可能性。毕竟，开心的话，也可以使用文言文。

结合 ArchGuard 中的 DSL 与可视化工具（这里采用的是 Mermaid.js），就能呈现我们所设计的分层架构：

 ![](/processor/blog/images?file_name=2022-05-14T12:01:03.999Z.svg)

再再结合一下设计的分层 Linter 工具（正在实现中）：

```javascript
linter('Backend').layer()
```

一旦分层中的依赖关系错了，就可以在持续集成中阻断这些代码的提交 —— 类似于 ArchUnit 这样的机制。稍有区别的是，你不需要将测试和代码放在代码库中，而是可以统一的去管理它们。

而对于其它一系列的更复杂的规则来说，我们可以自定义它们，并将他们与文档结合在一起。

### 架构文档即是规则

在这种模式之下，我们还可以将文档与代码相结合 —— 前提是：我们已经编写了一系列的规则。如我们在 ArchGuard 中，针对于不同的场景编写了一系列的规则：

* SQL，如不允许 `select *` 等
* Test Code，用于检测代码中的坏味道
* Web API ，分析 API 的设计是否 RESTful
* Layer （待实现），分析代码中的分层实现
* Arch （待实现），类似于 [ArchUnit](https://github.com/TNG/ArchUnit) 或者 [Guarding](https://github.com/modernizing/guarding) 制定更细的依赖规则
* Change（待实现），编写自定义的变更影响范围规则，如某个类不应该被其它的变更影响到

有了基本架构文档规范之后，我们可以规则化它们，并结合到一起。如下是一个结合 Checklist 和规则的列表示例：

```
- [x] 不应该存在被忽略（Ignore、Disabled）的测试用例 (#no-ignore-test)
- [ ] 允许存在重复的 assertion (#redundant-assertion) 
```

`#no-ignore-test` 对应于正在实现的 ArchGuard 中的规则，而 GFM 的 Checklist 中，如果 check 了，则可以表示为开启规则；如果没有 check，则为不开启。前面的文字部分，则是对应的规则描述，与传统的 linter 相比较，略显灵活。

而不论是编写文档还是阅读文档的人，他们可以很轻松地构建起对应的上下文。

### 设计、文档与代码一致

有了设计和文档之后，就需要结合到已有的代码中，让三者保持一致和准确。在我们的场景之下，就是 ArchGuard 已有的 API，它包含了：


1. 创建对于代码仓库的分析
2. 分析代码的语法和构建工具、变更历史等
3. 分析代码是否满足规则等

如下是 ArchGuard 中对于 repo 设计的 DSL（基于 Kotlin），用于创建代码仓库的分析：

```javascript
repos { 
    repo(name = "Backend", language = "Kotlin", scmUrl = "https://github.com/archguard/archguard")
    repo(name = "Frontend", language = "TypeScript", scmUrl = "https://github.com/archguard/archguard-frontend")
    repo(name = "Scanner", language = "Kotlin", scmUrl = "https://github.com/archguard/scanner")
}
```

只有三者保持了一致，我们才能确保架构的设计与实现是一致的。

## 架构即代码是个什么系统？

从实现的层面来说，一个架构即代码系统是一个支持编排的数据系统。原因在于，我们并不想关心数据处理的过程，但是想获取数据的结果，从结果中获取洞见。正如，我们所见到的一个个大数据系统，构建了一个个的可视化能力，以祈祷从中得到洞见。

不过，和祈祷稍有不同的是，我们是带着 N% 可能性的猜想，所以叫做探索。

### 一种探索式的架构治理

传统的软件开发模型是：**编辑-编译-运行**（edit-compile-run），这种开发模型的前提是，我们拥有足够的业务洞见。对于一个带着丰富领域知识的业务系统来说，构建这样一个系统并不是一件困难。但是，当我们缺乏足够的领域专家，我们应该如何往下走呢？复杂问题，你只能探索 (Probe)  -> 感知 (Sense) -> 响应 (Respond)。

而既然我们本身和很多新生代的架构师一样，也需要探索，也需要分析，然后才是得到结论。那么，我们不妨再尝试切换一下模式。如同，我们构建 ArchGuard 的软件开发模型，也是**执行-探索**（execute-explore），先从分析一下系统（发布一个分析功能），再配合已有的模式，最后得到 “结论” 或者规则（再发布一个 linter 功能）。

在数据领域，这种方式相当的流行，过去人们用 IPython，现在都改用 Jupyter；另外一个类型则是类似于 RMarkdown 提供的报表式的思路。

* IPython。 is a command shell for interactive computing in multiple programming languages.
* Jupyter Notebook. is a web-based interactive computing platform.
* R Markdown。Turn your analyses into high quality documents, reports, presentations and dashboards with *R Markdown*.
* D3.js 社区的 Observable。用于 Explore, analyze, and explain data. As a team.

从模式上来说，ArchGuard 更偏向于 RStudio 的模式，只是从社区的资源上来说，Jupyter 相关的实现比较多。

### 一个经常 OOM 的 “大数据系统”

在我们（ArchGuard core team）的 “数次讨论” 中，最终认为 ArchGuard 是一个大数据分析，而不是简单的数据分析。原因是系统中存在大量的 bug 和大数据相关的（狗头）：

* 存在一定数量的 Out of Memory。
* 大数据量情况下的可视化优化。

也就是所谓的 ”bug 驱动的架构设计“。

除此，之后另外一个颇有意思的点是，对于更大型的系统来说，它存在大量的新的提交，又或者是新的分支。我们即需要考虑：**应对持续提交的代码，构建增量分析的功能**。

当我们尝试使用大数据的思路，如 MapReduce、Streaming Analysis 相关的模式来解决相关的问题时，发现它是可以 work 的不错的 —— 毕竟都是数据分析。

## 在 ArchGuard 是如何实现的？

ArchGuard 围绕于 DSL + Kotlin REPL + 数据可视化，构建了一个可交互的架构分析与治理平台。因为还在实现中，所以叫下一代。

### 1. 提炼架构元素

上文中的（<https://ascode.ink/>）系列中，也包含了两个架构相关的工具，一个是代码生成 DSL：[Forming](https://github.com/inherd/forming)、另外一个则是架构守护 DSL：[Guarding](https://github.com/modernizing/guarding)。两个 DSL 所做的事情是，围绕**特定的规则**将**架构元素**组合到一起，这里的架构元素。

如果没有做过，这一个过程看上去是挺麻烦的，实现上有一些颇为简单的东西可以参考（复制）：

* 架构描述语言论文（ADL）。ADL 已经是一个很成熟的领域了，在设计模式火的那个年代，架构模式（《面向模式的软件架构》）也特别的火。
* 架构相关书籍的目录。一本好的架构书，只需要看目录就能有个索引，所以也就有了基本的架构元素。
* 架构的模式语言。模式语言所呈现的是模式之间的关系
* ……

仅仅是复制那多没意思，要是能自己做做抽象，也是一种非常好玩的事情。

### 2. 构建插件化与规则分析

如上所述，在 ArchGuard 中，我们尝试以一系列的规则，构建系统的规则，而这些规则是以插件化的形式暴露的。

这就意味着，这样一个系统应该是支持自定义的插件化能力，它即可以让你：


1. 接入一个新的语言
2. 编写新的规则
3. 构建新数据的 pipeline

在 ArchGuard 中还需要改进的是，提供一种元数据的能力。

### 3. 抽象 DSL 作为胶水

从实现层面来说，为了支撑粘合的能力，我们目前计划设计了三种能力的 DSL：**后端架构查询 DSL、架构 DSL、特征 DSL**。

**后端架构查询 DSL**

类似于 LINQ （Language Integrated Query，语言集成查询）封装 CRUD 接口，以提供编译时类型检查或智能感知支持，在 Kotlin 中有诸如于：[KtOrm](https://github.com/kotlin-orm/ktorm) 的形式。如：

```javascript
database
    .from(Employees)
    .select(Employees.name)
    .where { (Employees.departmentId eq 1) and (Employees.name like "%vince%") }
    .forEach { row -> 
        println(row[Employees.name])
    }
```

像一个编程语言编写，可以提供更友好的语法性支持。

**架构 DSL**

即架构描述语言（Architecture Description Language），以提供一种有效的方式来描述软件架构。

**特征 DSL：分析、扫描与 Linter**

即封装 ArchGuard Scanner、Analyser、Linter 等，用于构建系统所需要的基础性架构特征。

### 4. 构建可交互的环境

两年前，在与众多的 Thoughtworker 一起构建 [Ledge](https://github.com/phodal/ledge) 的时候，我们就一直在强调[文档代码化](https://www.phodal.com/blog/document-as-code/)，并提供可交互的文档环境。在 Ledge 里，你可以使用 Markdown 来绘制各类的图表，只需要借助声明图表类型，示例见：<https://devops.phodal.com/helper> 。

从模式上来说，ArchGuard 更像是一个  RStudio + Jupyter 的结合版，即提供了大量自定义图形 + 组件能力的 REPL。

在 REPL 上，由于我们计划使用 Kotlin 构建 DSL，所以需要寻找的是 Kotlin 的 REPL。Kotlin 官方创建的 [kotlin-jupyter](https://github.com/Kotlin/kotlin-jupyter) 便成为了一个很好的参考，可惜还没有用得上。与此同时，Kotlin 在设计初期就有了 Kotlin Scripting 的场景，所以其实 `kotlin-scripting-compiler-embeddable` 就能满足需求。于是，在 PoC 里，我们参考了 Apache Zeppelin 引入了 Kotlin REPL，并创建了一个 WebSocket 作为服务。

在可视化上，稍微复杂一些，需要构建一个 Markdown 解析器、Block 编辑器等。我们暂时采用了 Mermaid.js 作为可视化的图形库之一，另外的还有 D3.js、Echarts 也是其中之一。剩下的问题，便是如何通过 DSL 来整合它们？构建前后端的数据模型是一个临时的方案？

PoC 示例见截图：

### 5. 依旧是一个 PoC

在这里，ArchGuard 的交互性分析，依然只是一个 PoC（概念证明），但是在不远的将来，你就可以在 ArchGuard 中使用它了。

## 其它

构建一个这样复杂的工具，并不是一件容易的事。欢迎加入 ArchGuard，一起学习架构和架构治理，还有开发一个纯技术驱动的开源软件。

如果你想实践以下的技术，手把手教你学会：


1. 编译器前端。对设计和实现 DSL 有兴趣
2. 编译器周边。Kotlin 的编译器使用
3. ……

当然，如果你也感兴趣于：


1. 改进一个遗留系统。重构和设计 ArchGuard 的前端、后端。

虽然，我们无法向你提供 code，但是说不定未来可以呢 —— 作为一个开源的自研项目，万一能构建开放式的商业模式？除此，你可以 show your code in public，认更多的行业上的架构师认识你。

# 构建代码化

# 部署代码化

# 运营代码化

